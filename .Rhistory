data = df, cluster = ~ iso
)
# Joint tests of hazard variables (per model)
wald_asylum  <- wald(m_asylum_fe, "lag_drought_events = events_flood = events_hurricane = 0")
wald_intdisp <- wald(m_intdisp_fe, "events_drought = events_flood = events_hurricane = 0")
# ============== Robustness A: PPML-FE with population offset ==============
# Uses raw counts with log(pop) offset to model rates
m_asylum_ppml <- fepois(
asylum_apps ~ lag_drought_events + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, offset = ~ log(population), cluster = ~ iso
)
m_intdisp_ppml <- fepois(
total_int_disp ~ events_drought + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, offset = ~ log(population), cluster = ~ iso
)
# ============== Robustness B: Intensity (affected per capita) ==============
m_asylum_intensity <- feols(
log1p(asylum_apps) ~ lag_drought_events + affected_flood_pc + affected_hurricane_pc +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, cluster = ~ iso
)
# ============== Summaries / Tables ==============
etable(
m_asylum_fe, m_intdisp_fe, m_asylum_ppml, m_intdisp_ppml, m_asylum_intensity,
se = "cluster", cluster = "iso",
digits = 3,
fitstat = c("r2","n"),   # <- safe across versions
tex = FALSE,
headers = c("Asylum FE (log1p)", "Internal FE (log1p)",
"Asylum PPML (rate)", "Internal PPML (rate)",
"Asylum FE (intensity)")
)
# Safe extractors for fixest::wald across versions
`%||%` <- function(a, b) if (!is.null(a)) a else b
wald_extract <- function(w){
# Case 1: atomic numeric (often just the p-value)
if (is.numeric(w) && length(w) == 1L) {
return(list(stat = NA_real_, p = as.numeric(w)))
}
# Case 2: list-like with elements
if (is.list(w)) {
stat <- w$stat %||% w[["stat"]] %||% suppressWarnings(as.numeric(attr(w, "stat")))
pval <- w$p.value %||% w[["p.value"]] %||% suppressWarnings(as.numeric(attr(w, "p.value")))
return(list(stat = as.numeric(stat), p = as.numeric(pval)))
}
# Case 3: fall back to attributes
stat <- suppressWarnings(as.numeric(attr(w, "stat")))
pval <- suppressWarnings(as.numeric(attr(w, "p.value")))
list(stat = stat, p = pval)
}
asyl_w <- wald_extract(wald_asylum)
intd_w <- wald_extract(wald_intdisp)
data.frame(
Model   = c("Asylum FE hazards joint", "Internal FE hazards joint"),
Wald    = c(asyl_w$stat, intd_w$stat),
p_value = c(asyl_w$p,    intd_w$p)
) |> print(row.names = FALSE)
# ---- FE estimation & robustness for the model ----
#install.packages(c("fixest","broom","lmtest","sandwich","car"))
library(fixest); library(dplyr); library(broom); library(lmtest); library(sandwich); library(car)
df <- readr::read_csv("data/processed/panel_merged_wide.csv", show_col_types = FALSE)
# Construct any missing helpers
df <- df %>%
mutate(
# Intensity (affected per capita) if population available
affected_flood_pc      = ifelse(!is.na(population) & population>0, affected_flood / population, NA_real_),
affected_hurricane_pc  = ifelse(!is.na(population) & population>0, affected_hurricane / population, NA_real_),
affected_drought_pc    = ifelse(!is.na(population) & population>0, affected_drought / population, NA_real_),
# If your merge already created lag_drought_events, keep it; otherwise create:
lag_drought_events = ifelse(is.na(lag_drought_events),
dplyr::lag(events_drought, 1),
lag_drought_events)
) %>%
group_by(iso) %>%
arrange(year, .by_group = TRUE) %>%
ungroup()
# ============== Baseline FE: International (Asylum) ==============
m_asylum_fe <- feols(
log1p(asylum_apps) ~ lag_drought_events + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, cluster = ~ iso
)
# ============== Baseline FE: Internal Displacement ==============
m_intdisp_fe <- feols(
log1p(total_int_disp) ~ events_drought + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, cluster = ~ iso
)
# Joint tests of hazard variables (per model)
wald_asylum  <- wald(m_asylum_fe, "lag_drought_events = events_flood = events_hurricane = 0")
wald_intdisp <- wald(m_intdisp_fe, "events_drought = events_flood = events_hurricane = 0")
# ============== Robustness A: PPML-FE with population offset ==============
# Uses raw counts with log(pop) offset to model rates
m_asylum_ppml <- fepois(
asylum_apps ~ lag_drought_events + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, offset = ~ log(population), cluster = ~ iso
)
m_intdisp_ppml <- fepois(
total_int_disp ~ events_drought + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, offset = ~ log(population), cluster = ~ iso
)
# ============== Robustness B: Intensity (affected per capita) ==============
m_asylum_intensity <- feols(
log1p(asylum_apps) ~ lag_drought_events + affected_flood_pc + affected_hurricane_pc +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, cluster = ~ iso
)
# ============== Summaries / Tables ==============
etable(
m_asylum_fe, m_intdisp_fe, m_asylum_ppml, m_intdisp_ppml, m_asylum_intensity,
se = "cluster", cluster = "iso",
digits = 3,
fitstat = c("r2","n"),   # <- safe across versions
tex = FALSE,
headers = c("Asylum FE (log1p)", "Internal FE (log1p)",
"Asylum PPML (rate)", "Internal PPML (rate)",
"Asylum FE (intensity)")
)
# --- Safe Wald helpers that always return a scalar ---
safe_wald_p <- function(mod, hypo){
out <- tryCatch(fixest::wald(mod, hypo), error = function(e) NA)
if (is.numeric(out)) {
# Some fixest versions return a numeric (p or vector); take the first
return(as.numeric(out[1]))
} else if (is.list(out)) {
if (!is.null(out$p.value))       return(as.numeric(out$p.value))
if (!is.null(out[["p.value"]]))  return(as.numeric(out[["p.value"]]))
}
pv <- suppressWarnings(as.numeric(attr(out, "p.value")))
if (!is.na(pv)) return(pv)
NA_real_
}
safe_wald_stat <- function(mod, hypo){
out <- tryCatch(fixest::wald(mod, hypo), error = function(e) NA)
if (is.list(out)) {
if (!is.null(out$stat))        return(as.numeric(out$stat))
if (!is.null(out[["stat"]]))   return(as.numeric(out[["stat"]]))
}
st <- suppressWarnings(as.numeric(attr(out, "stat")))
if (!is.na(st)) return(st)
NA_real_
}
# --- Your joint tests (robust to version differences) ---
asyl_p  <- safe_wald_p(m_asylum_fe,  "lag_drought_events = events_flood = events_hurricane = 0")
# ---- FE estimation & robustness for the model ----
# install.packages(c("fixest","broom","lmtest","sandwich","car"))
library(fixest); library(dplyr); library(broom); library(lmtest); library(sandwich); library(car)
df <- readr::read_csv("data/processed/panel_merged_wide.csv", show_col_types = FALSE)
# ---- Helpers & constructed vars ----
df <- df %>%
mutate(
# Intensity (affected per capita) if population available
affected_flood_pc      = ifelse(!is.na(population) & population > 0, affected_flood     / population, NA_real_),
affected_hurricane_pc  = ifelse(!is.na(population) & population > 0, affected_hurricane / population, NA_real_),
affected_drought_pc    = ifelse(!is.na(population) & population > 0, affected_drought   / population, NA_real_)
) %>%
group_by(iso) %>%
arrange(year, .by_group = TRUE) %>%
mutate(
# Use existing lag if present; else create 1-year lag for drought events
lag_drought_events = ifelse(
"lag_drought_events" %in% names(cur_data_all()),
lag_drought_events,
dplyr::lag(events_drought, 1)
)
) %>%
ungroup()
# ================= Baseline FE models =================
# International (asylum)
m_asylum_fe <- feols(
log1p(asylum_apps) ~ lag_drought_events + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, cluster = ~ iso
)
# ---- Minimal FE & PPML models (simple, version-safe) ----
# install.packages(c("fixest","readr","dplyr"))
library(fixest)
library(readr)
library(dplyr)
# Load panel
df <- read_csv("data/processed/panel_merged_wide.csv", show_col_types = FALSE)
# Basic helpers (keep it simple)
df <- df %>%
arrange(iso, year) %>%
group_by(iso) %>%
mutate(
# 1-year lag for drought events (slow-onset logic)
lag_drought_events = dplyr::lag(events_drought, 1)
) %>%
ungroup() %>%
mutate(
# Per-capita intensities (safe division)
affected_flood_pc     = ifelse(!is.na(population) & population > 0, affected_flood     / population, NA_real_),
affected_hurricane_pc = ifelse(!is.na(population) & population > 0, affected_hurricane / population, NA_real_)
)
# ================= Baseline fixed-effects =================
# International (asylum)
m_asylum_fe <- feols(
log1p(asylum_apps) ~ lag_drought_events + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, cluster = ~ iso
)
# Internal displacement
m_intdisp_fe <- feols(
log1p(total_int_disp) ~ events_drought + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, cluster = ~ iso
)
# ================= Robustness: PPML with population offset =================
# Use pmax(population, 1) so log() is always defined
m_asylum_ppml <- fepois(
asylum_apps ~ lag_drought_events + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df,
offset = ~ log(pmax(population, 1)),
cluster = ~ iso
)
m_intdisp_ppml <- fepois(
total_int_disp ~ events_drought + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df,
offset = ~ log(pmax(population, 1)),
cluster = ~ iso
)
# ================= Alternative: intensity spec =================
m_asylum_intensity <- feols(
log1p(asylum_apps) ~ lag_drought_events + affected_flood_pc + affected_hurricane_pc +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index |
iso + year,
data = df, cluster = ~ iso
)
# ================= Tables (safe fit stats) =================
# FE + intensity
etable(
m_asylum_fe, m_intdisp_fe, m_asylum_intensity,
se = "cluster", cluster = "iso",
digits = 3, fitstat = c("r2","n"),
tex = FALSE,
headers = c("Asylum FE (log1p)", "Internal FE (log1p)", "Asylum FE (intensity)")
)
# PPML
etable(
m_asylum_ppml, m_intdisp_ppml,
se = "cluster", cluster = "iso",
digits = 3, fitstat = c("n"),
tex = FALSE,
headers = c("Asylum PPML (rate)", "Internal PPML (rate)")
)
# Helper functions to extract percent effects and stars from fixest models
fmt_eff <- function(mod, var, scale = 100){
ct <- tryCatch(summary(mod)$coeftable, error = function(e) NULL)
if(is.null(ct) || !(var %in% rownames(ct))) return(list(pct = "n/a", stars = ""))
b  <- ct[var, "Estimate"]
p  <- ct[var, "Pr(>|t|)"]
stars <- if(is.na(p)) "" else if(p < 0.01) "***" else if(p < 0.05) "**" else if(p < 0.1) "*" else ""
list(pct = sprintf("%.1f", scale*b), stars = stars)
}
fmt_wald <- function(w, label){
if(inherits(w, "try-error") || is.null(w$p.value) || is.na(w$p.value)) return(paste(label, ": p = n/a"))
paste0(label, ": p = ", format.pval(w$p.value, digits = 3))
}
# Pull effects
e1 <- fmt_eff(m_intdisp_fe, "events_flood")
e2 <- fmt_eff(m_intdisp_fe, "events_hurricane")
e3 <- fmt_eff(m_asylum_fe,   "lag_drought_events")
flood_intdisp_pct <- e1$pct
flood_intdisp_sig <- e1$stars
hurr_intdisp_pct  <- e2$pct
hurr_intdisp_sig  <- e2$stars
drought_asylum_pct<- e3$pct
drought_asylum_sig<- e3$stars
# Wald joint tests (if available)
wald_asylum_try  <- try(wald(m_asylum_fe,  "lag_drought_events = events_flood = events_hurricane = 0"), silent = TRUE)
wald_intdisp_try <- try(wald(m_intdisp_fe, "events_drought = events_flood = events_hurricane = 0"), silent = TRUE)
wald_asylum_txt  <- fmt_wald(wald_asylum_try,  "Hazards joint (asylum FE)")
# ---- Inline summaries + simple diagnostics (no Wald tests) ----
# install.packages(c("broom","lmtest","sandwich","car"))
library(broom); library(lmtest); library(sandwich); library(car)
# Helper to format percent effects and significance stars from fixest models
fmt_eff <- function(mod, var, scale = 100, stat_cols = c("Pr(>|t|)", "Pr(>|z|)")) {
ct <- tryCatch(summary(mod)$coeftable, error = function(e) NULL)
if (is.null(ct) || !(var %in% rownames(ct))) return(list(pct = "n/a", stars = ""))
b <- ct[var, "Estimate"]
p_col <- intersect(colnames(ct), stat_cols)
p <- if (length(p_col)) ct[var, p_col[1]] else NA_real_
stars <- if (is.na(p)) "" else if (p < 0.01) "***" else if (p < 0.05) "**" else if (p < 0.1) "*" else ""
list(pct = sprintf("%.1f", scale * b), stars = stars)
}
# --- Pull effects used in the prose (semi-elasticities ~ 100*beta) ---
e1 <- fmt_eff(m_intdisp_fe, "events_flood")          # flood -> internal displacement
e2 <- fmt_eff(m_intdisp_fe, "events_hurricane")      # hurricane -> internal displacement
e3 <- fmt_eff(m_asylum_fe,   "lag_drought_events")   # lagged drought -> asylum
flood_intdisp_pct  <- e1$pct
flood_intdisp_sig  <- e1$stars
hurr_intdisp_pct   <- e2$pct
hurr_intdisp_sig   <- e2$stars
drought_asylum_pct <- e3$pct
drought_asylum_sig <- e3$stars
# --- Brief blurbs for PPML and intensity robustness (no tests, just significance flags) ---
ppml_intdisp_brief <- {
ct <- try(summary(m_intdisp_ppml)$coeftable, silent = TRUE)
if (inherits(ct, "try-error")) "PPML not estimated"
else {
sf <- if ("events_flood"     %in% rownames(ct)) (ct["events_flood",     "Pr(>|z|)"] < 0.1) else FALSE
sh <- if ("events_hurricane" %in% rownames(ct)) (ct["events_hurricane", "Pr(>|z|)"] < 0.1) else FALSE
paste0("flood (", if (sf) "sig" else "n.s.", "), hurricane (", if (sh) "sig" else "n.s.", ")")
}
}
ppml_asylum_brief <- {
ct <- try(summary(m_asylum_ppml)$coeftable, silent = TRUE)
if (inherits(ct, "try-error")) "PPML not estimated"
else {
sd <- if ("lag_drought_events" %in% rownames(ct)) (ct["lag_drought_events", "Pr(>|z|)"] < 0.1) else FALSE
paste0("lagged drought (", if (sd) "sig" else "n.s.", ")")
}
}
intensity_brief <- {
ct <- try(summary(m_asylum_intensity)$coeftable, silent = TRUE)
if (inherits(ct, "try-error")) "Intensity model not estimated"
else {
sf <- if ("affected_flood_pc"     %in% rownames(ct)) (ct["affected_flood_pc",     "Pr(>|t|)"] < 0.1) else FALSE
sh <- if ("affected_hurricane_pc" %in% rownames(ct)) (ct["affected_hurricane_pc", "Pr(>|t|)"] < 0.1) else FALSE
paste0("affected flood pc (", if (sf) "sig" else "n.s.", "), affected hurricane pc (", if (sh) "sig" else "n.s.", ")")
}
}
# --- Light diagnostics (preview) ---
# Pooled OLS preview for heteroskedasticity and VIF (FE models already use clustered SEs)
ols_prev <- try(lm(
log1p(asylum_apps) ~ lag_drought_events + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index,
data = df
), silent = TRUE)
bp_p_txt <- if (inherits(ols_prev, "try-error")) {
"p = n/a"
} else {
p <- try(bptest(ols_prev)$p.value, silent = TRUE)
if (inherits(p, "try-error") || is.na(p)) "p = n/a" else paste0("p = ", format.pval(p, digits = 3))
}
vif_max_txt <- if (inherits(ols_prev, "try-error")) {
"n/a"
} else {
v <- try(car::vif(ols_prev), silent = TRUE)
if (inherits(v, "try-error")) "n/a" else sprintf("%.2f", max(v, na.rm = TRUE))
}
# (Optional) Print a tiny diagnostics summary to the console/log
data.frame(
Check = c("Breusch–Pagan (pooled preview) p-value", "Max VIF (pooled preview)"),
Value = c(bp_p_txt, vif_max_txt)
) %>% print(row.names = FALSE)
# ---- Inline summaries + simple diagnostics (no Wald tests) ----
# install.packages(c("broom","lmtest","sandwich","car"))
library(broom); library(lmtest); library(sandwich); library(car)
# Helper to format percent effects and significance stars from fixest models
fmt_eff <- function(mod, var, scale = 100, stat_cols = c("Pr(>|t|)", "Pr(>|z|)")) {
ct <- tryCatch(summary(mod)$coeftable, error = function(e) NULL)
if (is.null(ct) || !(var %in% rownames(ct))) return(list(pct = "n/a", stars = ""))
b <- ct[var, "Estimate"]
p_col <- intersect(colnames(ct), stat_cols)
p <- if (length(p_col)) ct[var, p_col[1]] else NA_real_
stars <- if (is.na(p)) "" else if (p < 0.01) "***" else if (p < 0.05) "**" else if (p < 0.1) "*" else ""
list(pct = sprintf("%.1f", scale * b), stars = stars)
}
# --- Pull effects used in the prose (semi-elasticities ~ 100*beta) ---
e1 <- fmt_eff(m_intdisp_fe, "events_flood")          # flood -> internal displacement
e2 <- fmt_eff(m_intdisp_fe, "events_hurricane")      # hurricane -> internal displacement
e3 <- fmt_eff(m_asylum_fe,   "lag_drought_events")   # lagged drought -> asylum
flood_intdisp_pct  <- e1$pct
flood_intdisp_sig  <- e1$stars
hurr_intdisp_pct   <- e2$pct
hurr_intdisp_sig   <- e2$stars
drought_asylum_pct <- e3$pct
drought_asylum_sig <- e3$stars
# --- Brief blurbs for PPML and intensity robustness (no tests, just significance flags) ---
ppml_intdisp_brief <- {
ct <- try(summary(m_intdisp_ppml)$coeftable, silent = TRUE)
if (inherits(ct, "try-error")) "PPML not estimated"
else {
sf <- if ("events_flood"     %in% rownames(ct)) (ct["events_flood",     "Pr(>|z|)"] < 0.1) else FALSE
sh <- if ("events_hurricane" %in% rownames(ct)) (ct["events_hurricane", "Pr(>|z|)"] < 0.1) else FALSE
paste0("flood (", if (sf) "sig" else "n.s.", "), hurricane (", if (sh) "sig" else "n.s.", ")")
}
}
ppml_asylum_brief <- {
ct <- try(summary(m_asylum_ppml)$coeftable, silent = TRUE)
if (inherits(ct, "try-error")) "PPML not estimated"
else {
sd <- if ("lag_drought_events" %in% rownames(ct)) (ct["lag_drought_events", "Pr(>|z|)"] < 0.1) else FALSE
paste0("lagged drought (", if (sd) "sig" else "n.s.", ")")
}
}
intensity_brief <- {
ct <- try(summary(m_asylum_intensity)$coeftable, silent = TRUE)
if (inherits(ct, "try-error")) "Intensity model not estimated"
else {
sf <- if ("affected_flood_pc"     %in% rownames(ct)) (ct["affected_flood_pc",     "Pr(>|t|)"] < 0.1) else FALSE
sh <- if ("affected_hurricane_pc" %in% rownames(ct)) (ct["affected_hurricane_pc", "Pr(>|t|)"] < 0.1) else FALSE
paste0("affected flood pc (", if (sf) "sig" else "n.s.", "), affected hurricane pc (", if (sh) "sig" else "n.s.", ")")
}
}
# --- Light diagnostics (preview) ---
# Pooled OLS preview for heteroskedasticity and VIF (FE models already use clustered SEs)
ols_prev <- try(lm(
log1p(asylum_apps) ~ lag_drought_events + events_flood + events_hurricane +
log1p(gdp_pc_const) + agri_va_pct + unemp_rate + remit_gdp_pct + gini_index,
data = df
), silent = TRUE)
bp_p_txt <- if (inherits(ols_prev, "try-error")) {
"p = n/a"
} else {
p <- try(bptest(ols_prev)$p.value, silent = TRUE)
if (inherits(p, "try-error") || is.na(p)) "p = n/a" else paste0("p = ", format.pval(p, digits = 3))
}
vif_max_txt <- if (inherits(ols_prev, "try-error")) {
"n/a"
} else {
v <- try(car::vif(ols_prev), silent = TRUE)
if (inherits(v, "try-error")) "n/a" else sprintf("%.2f", max(v, na.rm = TRUE))
}
# (Optional) Print a tiny diagnostics summary to the console/log
data.frame(
Check = c("Breusch–Pagan (pooled preview) p-value", "Max VIF (pooled preview)"),
Value = c(bp_p_txt, vif_max_txt)
) %>% print(row.names = FALSE)
library(dplyr); library(ggplot2)
res_df <- df %>%
select(iso, year) %>%
mutate(
resid_asyl  = as.numeric(resid(m_asylum_fe)),
fit_asyl    = as.numeric(fitted(m_asylum_fe)),
resid_int   = as.numeric(resid(m_intdisp_fe)),
fit_int     = as.numeric(fitted(m_intdisp_fe))
)
library(dplyr); library(ggplot2)
# Vars each model needs (to reconstruct the "used" rows)
vars_asyl <- c("asylum_apps","lag_drought_events","events_flood","events_hurricane",
"gdp_pc_const","agri_va_pct","unemp_rate","remit_gdp_pct","gini_index")
vars_int  <- c("total_int_disp","events_drought","events_flood","events_hurricane",
"gdp_pc_const","agri_va_pct","unemp_rate","remit_gdp_pct","gini_index")
# Subsets actually used by the models (drop rows with any NA in required vars)
asyl_used <- df %>%
select(iso, year, all_of(vars_asyl)) %>%
filter(if_all(all_of(vars_asyl), ~ !is.na(.))) %>%
mutate(
resid = as.numeric(resid(m_asylum_fe)),
fit   = as.numeric(fitted(m_asylum_fe))
)
int_used <- df %>%
select(iso, year, all_of(vars_int)) %>%
filter(if_all(all_of(vars_int), ~ !is.na(.))) %>%
mutate(
resid = as.numeric(resid(m_intdisp_fe)),
fit   = as.numeric(fitted(m_intdisp_fe))
)
# Residual-vs-fitted & QQ plots
p1 <- ggplot(asyl_used, aes(fit, resid)) +
geom_point(alpha = 0.4) +
geom_smooth(se = FALSE, method = "loess") +
labs(title = "Asylum FE: residuals vs fitted", x = "Fitted", y = "Residuals") +
theme_minimal()
p2 <- ggplot(asyl_used, aes(sample = resid)) +
stat_qq(alpha = 0.6) + stat_qq_line() +
labs(title = "Asylum FE: QQ plot of residuals") +
theme_minimal()
p3 <- ggplot(int_used, aes(fit, resid)) +
geom_point(alpha = 0.4) +
geom_smooth(se = FALSE, method = "loess") +
labs(title = "Internal FE: residuals vs fitted", x = "Fitted", y = "Residuals") +
theme_minimal()
p4 <- ggplot(int_used, aes(sample = resid)) +
stat_qq(alpha = 0.6) + stat_qq_line() +
labs(title = "Internal FE: QQ plot of residuals") +
theme_minimal()
print(p1); print(p2); print(p3); print(p4)
# Serial autocorrelation of residuals within countries (lag 1)
serial_summary <- list(
asylum   = asyl_used %>% arrange(iso, year) %>%
group_by(iso) %>% summarise(acf = cor(resid, dplyr::lag(resid), use = "pairwise.complete.obs"), .groups="drop") %>%
summarise(`Median ACF (asylum)` = round(median(acf, na.rm = TRUE), 3)),
internal = int_used %>% arrange(iso, year) %>%
group_by(iso) %>% summarise(acf = cor(resid, dplyr::lag(resid), use = "pairwise.complete.obs"), .groups="drop") %>%
summarise(`Median ACF (internal)` = round(median(acf, na.rm = TRUE), 3))
)
knitr::kable(dplyr::bind_cols(serial_summary$asylum, serial_summary$internal),
caption = "Lag-1 residual autocorrelation within countries")
# Top standardized residuals (potential outliers to inspect)
top_asyl <- asyl_used %>%
mutate(z = as.numeric(scale(resid))) %>%
slice_max(abs(z), n = 6) %>%
transmute(iso, year, `|z|` = round(abs(z), 2))
top_int <- int_used %>%
mutate(z = as.numeric(scale(resid))) %>%
slice_max(abs(z), n = 6) %>%
transmute(iso, year, `|z|` = round(abs(z), 2))
knitr::kable(top_asyl, caption = "Largest standardized residuals: Asylum FE")
knitr::kable(top_int,  caption = "Largest standardized residuals: Internal FE")
